#!/usr/bin/env node
/* eslint-disable no-console */
const fs = require('fs');
const path = require('path');
const { mkdir, readFile, writeFile } = require('fs/promises');

const API_ENDPOINT = 'https://commons.wikimedia.org/w/api.php';
const DEFAULT_MANIFEST = path.join('config', 'slider.manifest.json');
const DEFAULT_OUTPUT = path.join('assets', 'monuments');
const DEFAULT_ATTRIBUTIONS = path.join('assets', 'ATTRIBUTIONS.json');
const DEFAULT_IMAGE_MODULE = path.join('assets', 'monuments', 'index.js');

function parseArgs(argv) {
  const args = {};
  for (let i = 0; i < argv.length; i += 1) {
    const current = argv[i];
    if (!current.startsWith('--')) continue;
    const key = current.replace(/^--/, '');
    const next = argv[i + 1];
    if (!next || next.startsWith('--')) {
      args[key] = true;
    } else {
      args[key] = next;
      i += 1;
    }
  }
  return {
    manifest: args.manifest || args.m || DEFAULT_MANIFEST,
    outputDir: args.output || args.o || DEFAULT_OUTPUT,
    attribFile: args.attrib || args.a || DEFAULT_ATTRIBUTIONS,
    includeRisky: Boolean(args['include-risky'] || args.includeRisky),
    dryRun: Boolean(args['dry-run'] || args.dryRun),
  };
}

function stripHtml(value) {
  if (!value) return '';
  return value.replace(/<[^>]*>/g, '').replace(/&nbsp;/gi, ' ').trim();
}

async function ensureDir(targetPath) {
  await mkdir(targetPath, { recursive: true });
}

async function loadJsonIfExists(filePath, fallback) {
  try {
    const data = await readFile(filePath, 'utf8');
    return JSON.parse(data);
  } catch (error) {
    if (error.code === 'ENOENT') {
      return fallback;
    }
    throw error;
  }
}

async function fetchFileMetadata(fileTitle) {
  const params = new URLSearchParams({
    action: 'query',
    format: 'json',
    prop: 'imageinfo',
    titles: fileTitle,
    iiprop: 'url|dimensions|extmetadata|size|timestamp',
    iiurlwidth: '2048',
    origin: '*',
  });
  const response = await fetch(`${API_ENDPOINT}?${params.toString()}`);
  if (!response.ok) {
    throw new Error(`Wikimedia API request failed (${response.status}) for ${fileTitle}`);
  }
  const payload = await response.json();
  const pages = payload?.query?.pages || {};
  const page = Object.values(pages)[0];
  const info = page?.imageinfo?.[0];
  if (!info?.url) {
    throw new Error(`No image info found for ${fileTitle}`);
  }
  return { page, info };
}

function normalizeFileName(fileTitle) {
  return fileTitle
    .replace(/^File:/i, '')
    .replace(/[^a-z0-9_.-]+/gi, '_')
    .replace(/_+/g, '_')
    .toLowerCase();
}

async function downloadBinary(url) {
  const response = await fetch(url);
  if (!response.ok) {
    throw new Error(`Failed to download ${url} (${response.status})`);
  }
  const arrayBuffer = await response.arrayBuffer();
  return Buffer.from(arrayBuffer);
}

async function writeAttributions(filePath, data) {
  const serialized = `${JSON.stringify(data, null, 2)}\n`;
  await writeFile(filePath, serialized, 'utf8');
}

function formatJsValue(value) {
  if (value === undefined) {
    return 'null';
  }
  return JSON.stringify(value ?? null);
}

async function generateImageModule(attributions, monumentsDir, moduleFile) {
  const lines = [];
  lines.push('// Auto-generated by scripts/fetch-images.js');
  lines.push('// Do not edit manually.');
  lines.push('export const monumentImages = {');

  const slugs = Object.keys(attributions || {}).sort();
  for (const slug of slugs) {
    const entries = Array.isArray(attributions[slug]) ? attributions[slug] : [];
    if (!entries.length) continue;

    const validEntries = entries
      .map((entry) => {
        const filePath = path.join(monumentsDir, slug, entry.filename || '');
        if (!entry.filename || !fs.existsSync(filePath)) {
          return null;
        }
        const requirePath = `./${slug}/${entry.filename}`.replace(/\\/g, '/');
        return { entry, requirePath };
      })
      .filter(Boolean);

    if (!validEntries.length) continue;

    lines.push(`  "${slug}": [`);
    for (const { entry, requirePath } of validEntries) {
      lines.push('    {');
      lines.push(`      title: ${formatJsValue(entry.title)},`);
      lines.push(`      filename: ${formatJsValue(entry.filename)},`);
      lines.push(`      url: ${formatJsValue(entry.url)},`);
      lines.push(`      localPath: ${formatJsValue(entry.localPath)},`);
      lines.push(`      width: ${formatJsValue(entry.width)},`);
      lines.push(`      height: ${formatJsValue(entry.height)},`);
      lines.push(`      author: ${formatJsValue(entry.author)},`);
      lines.push(`      credit: ${formatJsValue(entry.credit)},`);
      lines.push(`      license: ${formatJsValue(entry.license)},`);
      lines.push(`      licenseUrl: ${formatJsValue(entry.licenseUrl)},`);
      lines.push(`      source: ${formatJsValue(entry.source)},`);
      lines.push(`      retrievedAt: ${formatJsValue(entry.retrievedAt)},`);
      lines.push(`      image: require('${requirePath}'),`);
      lines.push('    },');
    }
    lines.push('  ],');
  }

  lines.push('};');
  lines.push('export default monumentImages;');
  await writeFile(moduleFile, `${lines.join('\n')}\n`, 'utf8');
}

(async () => {
  const options = parseArgs(process.argv.slice(2));
  const manifestPath = path.resolve(process.cwd(), options.manifest);
  const outputDir = path.resolve(process.cwd(), options.outputDir);
  const attribPath = path.resolve(process.cwd(), options.attribFile);
  const imageModulePath = path.resolve(process.cwd(), DEFAULT_IMAGE_MODULE);

  const manifest = await loadJsonIfExists(manifestPath, {});
  const monuments = Array.isArray(manifest.monuments) ? manifest.monuments : [];
  if (!monuments.length) {
    console.warn('No monuments found in manifest.');
    return;
  }

  const attributions = await loadJsonIfExists(attribPath, {});
  let totalDownloads = 0;

  for (const monument of monuments) {
    const { slug, title, wikimedia_files: files = [], license_note: licenseNote } = monument;
    if (!slug) {
      console.warn('Skipping entry without slug');
      continue;
    }
    if (licenseNote && !options.includeRisky) {
      console.log(`Skipping ${slug} (${title || 'sin título'}) por licencia: ${licenseNote}`);
      continue;
    }
    if (!files.length) {
      console.warn(`No files listed for ${slug}`);
    }

    const monumentDir = path.join(outputDir, slug);
    if (!options.dryRun) {
      await ensureDir(monumentDir);
    }

    const collected = [];
    for (const fileTitle of files) {
      try {
        const { info } = await fetchFileMetadata(fileTitle);
        const normalizedName = normalizeFileName(fileTitle);
        const targetPath = path.join(monumentDir, normalizedName);
        const localPath = path.relative(process.cwd(), targetPath).replace(/\\/g, '/');

        if (!options.dryRun) {
          const buffer = await downloadBinary(info.url);
          await writeFile(targetPath, buffer);
        }

        collected.push({
          title: title || slug,
          filename: normalizedName,
          url: info.descriptionurl || info.url,
          localPath,
          width: info.width,
          height: info.height,
          author: stripHtml(info.extmetadata?.Artist?.value),
          credit: stripHtml(info.extmetadata?.Credit?.value),
          license: stripHtml(
            info.extmetadata?.LicenseShortName?.value || info.extmetadata?.License?.value
          ),
          licenseUrl: stripHtml(info.extmetadata?.LicenseUrl?.value),
          source: info.url,
          retrievedAt: new Date().toISOString(),
        });
        totalDownloads += 1;
        console.log(`✔ ${slug} → ${normalizedName}`);
      } catch (error) {
        console.warn(`⚠️  Error downloading ${fileTitle} (${slug}): ${error.message}`);
      }
    }

    if (collected.length) {
      attributions[slug] = collected;
    }
  }

  if (!options.dryRun) {
    await ensureDir(path.dirname(attribPath));
    await writeAttributions(attribPath, attributions);
    await generateImageModule(attributions, outputDir, imageModulePath);
  }

  console.log(`Descargas completadas: ${totalDownloads}`);
  if (!options.dryRun) {
    console.log(`Archivo de atribuciones actualizado en ${path.relative(process.cwd(), attribPath)}`);
    console.log(`Módulo de imágenes actualizado en ${path.relative(process.cwd(), imageModulePath)}`);
  } else {
    console.log('Ejecución en modo dry-run, no se escribieron archivos.');
  }
})().catch((error) => {
  console.error(error);
  process.exitCode = 1;
});
